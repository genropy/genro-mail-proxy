
API Reference
=============

FastAPI
-------

The REST API is served by FastAPI.  The automatically generated documentation
is available at:

* OpenAPI JSON: ``http://localhost:8000/openapi.json``
* Swagger UI: ``http://localhost:8000/docs``
* ReDoc: ``http://localhost:8000/redoc``

All endpoints require the ``X-API-Token`` header when
``GMP_API_TOKEN`` is configured.

Core endpoints
--------------

``POST /commands/run-now``
   Wake the dispatcher and reporting loops so they execute a cycle immediately
   instead of waiting for the next scheduled interval. Useful for maintenance
   scripts and for ``test_mode`` instances where the interval is effectively
   infinite.

``POST /commands/suspend`` / ``POST /commands/activate``
   Toggle the scheduler.

``POST /commands/add-messages``
   Validate and enqueue a batch of messages.  Each payload entry matches
   :class:`mail_proxy.api.MessagePayload`; the response contains the
   number of queued items plus a ``rejected`` list with ``{"id","reason"}``
   entries describing invalid payloads (missing ``id``, bad addresses, unknown
   account, duplicates, ...).

``POST /account`` / ``GET /accounts`` / ``DELETE /account/{id}``
   Manage SMTP account credentials.

``GET /messages``
   Inspect the SQLite-backed ``messages`` table.  Each record includes the
   payload plus lifecycle fields (``priority``, ``deferred_ts``, ``sent_ts``,
   ``error_ts``, ``error``, ``reported_ts``).

``GET /metrics``
   Expose Prometheus metrics generated by
   :class:`mail_proxy.prometheus.MailMetrics`.

Tenant management
-----------------

These endpoints manage tenant configurations for multi-tenant deployments.
See :doc:`multi_tenancy` for full architecture details.

``POST /tenant``
   Create or update a tenant configuration.

   Request body:

   .. code-block:: json

      {
        "id": "tenant-acme",
        "name": "ACME Corporation",
        "client_base_url": "https://api.acme.com",
        "client_sync_path": "/mail-proxy/sync",
        "client_attachment_path": "/mail-proxy/attachments",
        "client_auth": {
          "method": "bearer",
          "token": "secret-token"
        },
        "rate_limits": {
          "hourly": 1000,
          "daily": 10000
        },
        "large_file_config": {
          "enabled": true,
          "max_size_mb": 10,
          "storage_url": "s3://bucket/mail-attachments",
          "file_ttl_days": 30,
          "action": "rewrite"
        },
        "active": true
      }

   **large_file_config fields:**

   - ``enabled`` (bool): Enable large file handling (default: false)
   - ``max_size_mb`` (float): Size threshold in MB (default: 10.0)
   - ``storage_url`` (string): fsspec URL for storage backend:
     - S3/MinIO: ``s3://bucket/path``
     - Google Cloud Storage: ``gs://bucket/path``
     - Azure Blob: ``az://container/path``
     - Local filesystem: ``file:///var/www/downloads``
   - ``public_base_url`` (string): Required for local filesystem storage
   - ``file_ttl_days`` (int): Days before files expire (default: 30)
   - ``lifespan_after_download_days`` (int): Days to keep after first download
   - ``action`` (string): Behavior when limit exceeded:
     - ``warn``: Log warning, send normally (default)
     - ``reject``: Reject message with error
     - ``rewrite``: Upload to storage, replace with download link

   Response: ``{"ok": true}``

``GET /tenants``
   List all configured tenants.

   Query parameters:

   - ``active_only`` (bool, optional): Filter to active tenants only

   Response:

   .. code-block:: json

      {
        "ok": true,
        "tenants": [
          {
            "id": "tenant-acme",
            "name": "ACME Corporation",
            "client_sync_url": "https://api.acme.com/proxy_sync",
            "active": true,
            "created_at": "2024-01-20T10:00:00Z"
          }
        ]
      }

``GET /tenant/{tenant_id}``
   Get a specific tenant configuration.

   Response: Single tenant object or ``404`` if not found.

``PUT /tenant/{tenant_id}``
   Update an existing tenant. All fields are optional.

   Response: ``{"ok": true}``

``DELETE /tenant/{tenant_id}``
   Remove a tenant configuration.

   Response: ``{"ok": true}``

Additional commands
-------------------

``POST /commands/delete-messages?tenant_id=<tenant_id>``
   Remove messages from the queue by their IDs.

   Query parameters:

   - ``tenant_id`` (string, required): Tenant identifier for security isolation

   Request body:

   .. code-block:: json

      {
        "ids": ["MSG-001", "MSG-002"]
      }

   Response:

   .. code-block:: json

      {
        "ok": true,
        "removed": 2,
        "not_found": [],
        "unauthorized": []
      }

   The ``unauthorized`` field contains IDs of messages that belong to a different tenant.

``POST /commands/cleanup-messages?tenant_id=<tenant_id>``
   Remove old reported messages based on retention policy.

   Query parameters:

   - ``tenant_id`` (string, required): Tenant identifier for security isolation

   Request body (optional):

   .. code-block:: json

      {
        "older_than_seconds": 86400
      }

   If ``older_than_seconds`` is not provided, uses the configured
   ``report_retention_seconds`` value.

   Response:

   .. code-block:: json

      {
        "ok": true,
        "removed": 42
      }

Prometheus metrics
------------------

The following metrics are exported (all prefixed with ``gmp_`` for genro-mail-proxy):

* ``gmp_sent_total{account_id}`` - Total successfully sent emails
* ``gmp_errors_total{account_id}`` - Total permanent send failures
* ``gmp_deferred_total{account_id}`` - Total temporarily deferred messages
* ``gmp_rate_limited_total{account_id}`` - Total rate limit enforcement events
* ``gmp_pending_messages`` - Current queue depth

Outbound proxy sync
-------------------

Besides REST endpoints that clients call, the service also issues a
``POST`` request to the configured ``client_sync_url`` whenever there are
delivery results to share with your application.  Example payload:

The payload contains the delivery results read from the ``messages`` table:

.. code-block:: json

   {
     "delivery_report": [
       {
         "id": "MSG-101",
         "account_id": "accA",
         "priority": 1,
         "sent_ts": 1728458400,
         "error_ts": null,
         "error": null,
         "deferred_ts": null
       },
       {
         "id": "MSG-102",
         "account_id": "accA",
         "priority": 2,
         "sent_ts": null,
         "error_ts": 1728458612,
         "error": "SMTP timeout",
         "deferred_ts": null
       }
     ]
   }

Your application should reply with a JSON summary (for example
``{"sent": 12, "error": 1, "deferred": 3}``). Upon success the dispatcher sets
``reported_ts`` on the transmitted rows and cleans up any message whose
``reported_ts`` is older than the configured retention window.

Client Callback Endpoints
-------------------------

These endpoints are **NOT** exposed by the proxy. Your application must implement
them to receive callbacks from the proxy.

Delivery Report Endpoint
^^^^^^^^^^^^^^^^^^^^^^^^

The proxy sends delivery reports to your ``client_sync_url`` (configured per-tenant
or globally). Your endpoint must:

- Accept POST requests with JSON body containing ``delivery_report`` array
- Return a JSON summary response

Example implementation:

.. code-block:: python

   @app.post("/delivery-report")
   async def receive_delivery_report(request: Request):
       data = await request.json()
       reports = data.get("delivery_report", [])

       sent = sum(1 for r in reports if r.get("sent_ts"))
       error = sum(1 for r in reports if r.get("error_ts"))
       deferred = sum(1 for r in reports if r.get("deferred_ts"))

       # Update your local database with delivery status...

       return {"sent": sent, "error": error, "deferred": deferred}

Attachment Endpoint (optional)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If using ``fetch_mode: "endpoint"`` for attachments, the proxy fetches file content
from your ``client_attachment_url``. Your endpoint receives a POST with the
``storage_path`` value and must return the file content.

Example implementation:

.. code-block:: python

   @app.post("/attachments")
   async def serve_attachment(request: Request):
       data = await request.json()
       storage_path = data.get("storage_path")  # e.g., "doc_id=123"

       # Parse storage_path and fetch file from your storage
       file_content = fetch_file_from_storage(storage_path)

       return Response(content=file_content, media_type="application/octet-stream")
