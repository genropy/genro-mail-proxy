#!/usr/bin/env python3
"""
Example Client for genro-mail-proxy

This standalone server demonstrates how to integrate with genro-mail-proxy.
It provides endpoints to generate test messages and shows the recommended pattern:
1. Write message to local database
2. Submit message to mail service via REST API
3. Trigger immediate dispatch (optional, best-effort)
4. Handle delivery reports via proxy_sync endpoint

Usage:
    python3 example_client.py

Then send test messages:
    curl -X POST http://localhost:8081/send-test-email
    curl -X POST http://localhost:8081/send-test-email?count=5
"""

import asyncio
import configparser
import logging
import random
import sqlite3
import time
from datetime import datetime
from typing import Optional

import aiohttp
import uvicorn
from fastapi import FastAPI, HTTPException, Query, Request

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] [%(levelname)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)


class ExampleClient:
    """
    Example client demonstrating integration with genro-mail-proxy.

    This simulates a real application (like Genropy) that needs to send emails.
    It shows the recommended decoupling pattern:
    - Local persistence first (your database)
    - Async submission to mail service
    - Optional immediate trigger
    - Delivery report handling
    """

    def __init__(self, config_path: str = "example_config.ini"):
        self.config = configparser.ConfigParser()
        self.config.read(config_path)

        # Server configuration
        self.port = self.config.getint('server', 'port', fallback=9090)

        # Mail service connection
        self.mail_service_url = self.config.get('mail_service', 'url', fallback='http://localhost:8000')
        self.api_token = self.config.get('mail_service', 'api_token', fallback='your-secret-token')

        # Test message configuration
        self.test_recipient = self.config.get('test', 'recipient_email')
        self.test_sender = self.config.get('test', 'sender_email', fallback='test@example.com')
        self.test_sender_name = self.config.get('test', 'sender_name', fallback='Example Client')
        self.account_id = self.config.get('test', 'account_id', fallback=None)

        # Local database (simulating your application's DB)
        self.db_path = self.config.get('database', 'path', fallback='example_client.db')
        self._init_database()

        logger.info(f"Example client initialized")
        logger.info(f"Server port: {self.port}")
        logger.info(f"Mail service: {self.mail_service_url}")
        logger.info(f"Test recipient: {self.test_recipient}")
        logger.info(f"Account ID: {self.account_id}")
        logger.info(f"Local database: {self.db_path}")

    def _init_database(self):
        """Initialize local database to track messages."""
        conn = sqlite3.connect(self.db_path)
        conn.execute("""
            CREATE TABLE IF NOT EXISTS outbound_emails (
                id TEXT PRIMARY KEY,
                recipient TEXT NOT NULL,
                subject TEXT NOT NULL,
                body TEXT NOT NULL,
                created_at INTEGER NOT NULL,
                submitted_at INTEGER,
                delivered_at INTEGER,
                error TEXT,
                status TEXT DEFAULT 'pending'
            )
        """)
        conn.execute("""
            CREATE INDEX IF NOT EXISTS idx_status ON outbound_emails(status)
        """)
        conn.commit()
        conn.close()
        logger.info("Local database initialized")

    async def create_test_message(self, custom_subject: Optional[str] = None) -> dict:
        """
        Step 1: Create message in local database (YOUR application's DB).

        This represents your application committing a message before submission.
        Even if the mail service is down, this message is persisted locally.
        """
        message_id = f"test_{int(time.time() * 1000)}_{random.randint(1000, 9999)}"

        # Generate realistic test content
        subjects = [
            "Test Email from Example Client",
            "Integration Test Message",
            "Sample Email via Async Mail Service",
            "Test: Email Delivery Verification"
        ]
        subject = custom_subject or random.choice(subjects)

        body = f"""
        <html>
        <body>
            <h2>Test Email</h2>
            <p>This is a test message generated by the example client at {datetime.now().isoformat()}</p>
            <p><strong>Message ID:</strong> {message_id}</p>
            <p>This message demonstrates the integration pattern with genro-mail-proxy:</p>
            <ol>
                <li>Message created in local database (your app's DB)</li>
                <li>Submitted to mail service via REST API</li>
                <li>Immediate dispatch triggered (optional)</li>
                <li>Delivery report received via proxy_sync endpoint</li>
            </ol>
            <p style="color: #666; font-size: 12px;">
                Generated by example_client.py
            </p>
        </body>
        </html>
        """

        # Store in local database FIRST
        conn = sqlite3.connect(self.db_path)
        conn.execute("""
            INSERT INTO outbound_emails (id, recipient, subject, body, created_at, status)
            VALUES (?, ?, ?, ?, ?, 'pending')
        """, (message_id, self.test_recipient, subject, body, int(time.time())))
        conn.commit()
        conn.close()

        logger.info(f"Created message {message_id} in local database")

        msg = {
            'id': message_id,
            'to': self.test_recipient,
            'from': self.test_sender,
            'from_name': self.test_sender_name,
            'subject': subject,
            'body': body,
            'html': True
        }

        # Add account_id if configured
        if self.account_id:
            msg['account_id'] = self.account_id

        return msg

    async def submit_to_mail_service(self, messages: list[dict]) -> dict:
        """
        Step 2: Submit message(s) to mail service.

        This uses the /commands/add-messages endpoint to hand off email
        delivery responsibility to the mail service.
        """
        async with aiohttp.ClientSession() as session:
            headers = {
                'X-API-Token': self.api_token,
                'Content-Type': 'application/json'
            }

            url = f"{self.mail_service_url}/commands/add-messages"

            try:
                async with session.post(url, json={'messages': messages}, headers=headers) as resp:
                    if resp.status != 200:
                        error_text = await resp.text()
                        raise HTTPException(status_code=resp.status, detail=f"Mail service error: {error_text}")

                    result = await resp.json()
                    logger.info(f"Submitted {len(messages)} message(s) to mail service: {result}")

                    # Update local database
                    conn = sqlite3.connect(self.db_path)
                    for msg in messages:
                        conn.execute("""
                            UPDATE outbound_emails
                            SET submitted_at = ?, status = 'submitted'
                            WHERE id = ?
                        """, (int(time.time()), msg['id']))
                    conn.commit()
                    conn.close()

                    return result
            except aiohttp.ClientError as e:
                logger.error(f"Failed to submit to mail service: {e}")
                raise HTTPException(status_code=503, detail=f"Mail service unavailable: {str(e)}")

    async def trigger_immediate_dispatch(self):
        """
        Step 3: Trigger immediate dispatch (optional, best-effort).

        This is the "run-now" trigger that wakes up the SMTP dispatch loop.
        If this fails, the polling mechanism will still process the message.
        """
        async with aiohttp.ClientSession() as session:
            headers = {'X-API-Token': self.api_token}
            url = f"{self.mail_service_url}/commands/run-now"

            try:
                async with session.post(url, headers=headers) as resp:
                    if resp.status == 200:
                        logger.info("Triggered immediate dispatch")
                    else:
                        logger.warning(f"Failed to trigger immediate dispatch: {resp.status}")
            except aiohttp.ClientError as e:
                logger.warning(f"Could not trigger immediate dispatch (non-fatal): {e}")

    def get_pending_messages(self) -> list[dict]:
        """Get messages from local database that haven't been delivered yet."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.execute("""
            SELECT id, recipient, subject, status, created_at, submitted_at
            FROM outbound_emails
            WHERE status IN ('pending', 'submitted')
            ORDER BY created_at DESC
        """)

        messages = []
        for row in cursor.fetchall():
            messages.append({
                'id': row[0],
                'recipient': row[1],
                'subject': row[2],
                'status': row[3],
                'created_at': datetime.fromtimestamp(row[4]).isoformat(),
                'submitted_at': datetime.fromtimestamp(row[5]).isoformat() if row[5] else None
            })

        conn.close()
        return messages

    def get_message_stats(self) -> dict:
        """Get statistics about messages in local database."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.execute("""
            SELECT
                COUNT(*) as total,
                SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
                SUM(CASE WHEN status = 'submitted' THEN 1 ELSE 0 END) as submitted,
                SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
                SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed
            FROM outbound_emails
        """)

        row = cursor.fetchone()
        conn.close()

        return {
            'total': row[0],
            'pending': row[1] or 0,
            'submitted': row[2] or 0,
            'delivered': row[3] or 0,
            'failed': row[4] or 0
        }


# Initialize FastAPI app
app = FastAPI(
    title="Example Mail Service Client",
    description="Demonstrates integration with genro-mail-proxy",
    version="1.0.0"
)

# Initialize client
client = ExampleClient()


@app.get("/")
async def root():
    """Welcome endpoint with usage instructions."""
    return {
        'service': 'Example Mail Service Client',
        'description': 'Demonstrates integration with genro-mail-proxy',
        'endpoints': {
            '/send-test-email': 'POST - Generate and send test email(s)',
            '/messages': 'GET - List pending messages',
            '/stats': 'GET - Get message statistics',
            '/proxy_sync': 'POST - Receive delivery reports from mail service'
        },
        'usage': {
            'send_single': 'curl -X POST http://localhost:8081/send-test-email',
            'send_multiple': 'curl -X POST http://localhost:8081/send-test-email?count=5',
            'view_stats': 'curl http://localhost:8081/stats'
        }
    }


@app.post("/send-test-email")
async def send_test_email(
    count: int = Query(1, ge=1, le=100, description="Number of test emails to send"),
    subject: Optional[str] = Query(None, description="Custom subject line")
):
    """
    Generate and send test email(s).

    This endpoint demonstrates the complete integration flow:
    1. Creates message(s) in local database
    2. Submits to mail service
    3. Triggers immediate dispatch

    Query Parameters:
    - count: Number of emails to send (1-100, default 1)
    - subject: Custom subject line (optional)
    """
    try:
        # Step 1: Create messages in local database
        messages = []
        for i in range(count):
            custom_subj = f"{subject} ({i+1}/{count})" if subject and count > 1 else subject
            msg = await client.create_test_message(custom_subject=custom_subj)
            messages.append(msg)

        # Step 2: Submit to mail service
        result = await client.submit_to_mail_service(messages)

        # Step 3: Trigger immediate dispatch (best-effort)
        await client.trigger_immediate_dispatch()

        return {
            'status': 'success',
            'message': f'Successfully queued {count} test email(s)',
            'messages': [msg['id'] for msg in messages],
            'mail_service_response': result,
            'note': 'Check /stats endpoint to monitor delivery status'
        }

    except Exception as e:
        logger.error(f"Error sending test email: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/messages")
async def list_messages():
    """List pending messages from local database."""
    try:
        messages = client.get_pending_messages()
        return {
            'status': 'success',
            'count': len(messages),
            'messages': messages
        }
    except Exception as e:
        logger.error(f"Error listing messages: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/stats")
async def get_stats():
    """Get message statistics."""
    try:
        stats = client.get_message_stats()
        return {
            'status': 'success',
            'statistics': stats
        }
    except Exception as e:
        logger.error(f"Error getting stats: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/email/mailproxy/mp_endpoint/proxy_sync")
async def proxy_sync(request: Request):
    """
    Delivery report endpoint (called by mail service).

    This receives delivery confirmations from genro-mail-proxy.
    The path matches the Genropy convention for compatibility.
    """
    try:
        data = await request.json()
        reports = data.get('reports', [])

        logger.info(f"Received {len(reports)} delivery report(s)")

        # Update local database with delivery status
        conn = sqlite3.connect(client.db_path)

        for report in reports:
            msg_id = report.get('id')
            status = report.get('status')
            error = report.get('error')

            if status == 'sent':
                conn.execute("""
                    UPDATE outbound_emails
                    SET delivered_at = ?, status = 'delivered'
                    WHERE id = ?
                """, (int(time.time()), msg_id))
                logger.info(f"Message {msg_id} marked as delivered")

            elif status == 'error':
                conn.execute("""
                    UPDATE outbound_emails
                    SET error = ?, status = 'failed'
                    WHERE id = ?
                """, (error, msg_id))
                logger.warning(f"Message {msg_id} failed: {error}")

        conn.commit()
        conn.close()

        # Acknowledge receipt
        return {
            'status': 'ok',
            'processed': len(reports)
        }

    except Exception as e:
        logger.error(f"Error processing delivery reports: {e}")
        raise HTTPException(status_code=500, detail=str(e))


if __name__ == "__main__":
    logger.info("Starting example client server...")
    logger.info(f"Test emails will be sent to: {client.test_recipient}")
    logger.info(f"Server listening on port: {client.port}")
    logger.info("")
    logger.info("Try these commands:")
    logger.info(f"  curl -X POST http://localhost:{client.port}/send-test-email")
    logger.info(f"  curl -X POST http://localhost:{client.port}/send-test-email?count=5")
    logger.info(f"  curl http://localhost:{client.port}/stats")
    logger.info("")

    uvicorn.run(app, host="0.0.0.0", port=client.port, log_level="info")
